# Echomate Backend Development - MVP Task List (Simple & Refined)

## ðŸ” Phase 1: Authentication & Authorization (AWS Cognito)
- [ ] **1.1 Set Up AWS Cognito User Pool**
  - [ ] Configure user pool with email/password authentication (using Amplify JS Library *only* for Cognito auth and token handling)
  - [ ] Set up required user attributes (email, name, etc.)
  - [ ] Configure password policies and security settings

- [ ] **1.2 Implement Authentication Flow**
  - [ ] Set up sign-up, sign-in, and password reset flows via Amplify
  - [ ] Use Cognito's built-in JWT handling (no extra cost)

- [ ] **1.3 Authorization & Profile Creation**
  - [ ] Use the free, built-in Cognito Authorizer in API Gateway
  - [ ] **(Simplicity) Create a Post-Confirmation Lambda Trigger to auto-create user profiles in DynamoDB.**

## ðŸ“¦ Phase 2: Database Design & Implementation (DynamoDB)
- [ ] **2.1 User Table Design**
  - [ ] Define schema with nested JSON for profile flexibility
  - [ ] Plan for partial updates using `UpdateExpression` for efficiency
  - [ ] Set table to **On-Demand capacity** to only pay for what you use

- [ ] **2.2 Posts & Interactions Tables**
  - [ ] Define schemas for Posts and Interactions (Likes).
  - [ ] **(Simplicity) For Interactions table, use a Composite Key (postId + userId) for efficient lookups.**
  - [ ] Set tables to **On-Demand capacity** for cost control

## ðŸ”„ Phase 3: API Development (Lambda & API Gateway)
- [ ] **3.1 API Logic (Monolithic Lambda)**
  - [ ] **(Simplicity) Create a single "monolithic" Lambda function to handle all API endpoints.**
  - [ ] **(Simplicity) Implement an internal router (e.g., a switch statement) within the Lambda to direct traffic.**
  - [ ] Keep function code small and dependencies minimal to reduce cold starts
  - [ ] Avoid placing the function in a VPC unless essential
  > *Note: For scaling beyond MVP, consider splitting this Lambda into micro-Lambdas via routing-based architecture or API Gateway routes.*

- [ ] **3.2 Lambda Versioning**
  - [ ] Use free Lambda aliases (`prod`, `staging`) for version management

## ðŸ“¸ Phase 4: Media Storage (S3)
- [ ] **4.1 S3 Bucket Setup**
  - [ ] Configure bucket policies to deny public access by default
  - [ ] Set up CORS for your frontend domain
  - [ ] **(Simplicity) Create an S3 Lifecycle Policy to auto-delete orphaned files from a temp upload folder after 24 hours.**

- [ ] **4.2 Secure Media Upload System**
  - [ ] Implement pre-signed URLs generated by Lambda for secure, low-cost uploads
  - [ ] Validate file size and type in frontend and Lambda (free)
  > *Optional: For future performance, add CloudFront in front of S3 for caching and lower latency.*

## ðŸ”’ Phase 5: Security Implementation
- [ ] **5.1 API Security**
  - [ ] Use API Gateway's built-in throttling (free) for rate limiting
  - [ ] Avoid AWS WAF for now to save on fixed monthly costs

- [ ] **5.2 Data Security**
  - [ ] Use default encryption for DynamoDB and S3 (free)
  - [ ] Set up a billing alarm in CloudWatch to monitor costs (free)

## ðŸš€ Phase 7: Deployment
- [ ] **7.1 Frontend Deployment**
  - [ ] **(AWS-Only) Use AWS Amplify Hosting for the frontend**, leveraging its free tier and seamless integration.
  - [ ] Set up CI/CD through their GitHub integration

- [ ] **7.2 Backend Deployment**
  - [ ] Deploy the single Lambda and API Gateway updates via AWS CLI or simple GitHub Actions scripts

## ðŸ“ˆ Phase 8: Launch & Maintenance
- [ ] **8.1 Monitoring**
  - [ ] Use CloudWatch Dashboards and Alarms (within the free tier) to monitor key metrics
  - [ ] Focus on billing alarms, Lambda errors, and API Gateway latency

- [ ] **8.2 Pre-launch Testing**
  - [ ] Perform rigorous manual testing instead of paid load-testing services
  - [ ] Ask friends to help test to simulate concurrent users for free
